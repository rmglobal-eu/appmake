import { create } from "zustand";
import type { FileEntry } from "@/types/sandbox";

interface OpenFile {
  path: string;
  content: string;
  isDirty: boolean;
}

const MAX_UNDO_HISTORY = 50;

interface EditorStore {
  openFiles: OpenFile[];
  activeFilePath: string | null;
  /** All files generated by AI, keyed by path */
  generatedFiles: Record<string, string>;
  /** Undo/redo history stack */
  undoStack: Record<string, string>[];
  redoStack: Record<string, string>[];
  openFile: (path: string, content: string) => void;
  closeFile: (path: string) => void;
  setActiveFile: (path: string) => void;
  updateFileContent: (path: string, content: string) => void;
  markFileSaved: (path: string) => void;
  addGeneratedFile: (path: string, content: string) => void;
  addGeneratedFiles: (files: Record<string, string>) => void;
  clearGeneratedFiles: () => void;
  /** Push current state to undo stack (call before batch changes) */
  pushUndoSnapshot: () => void;
  undo: () => void;
  redo: () => void;
  canUndo: () => boolean;
  canRedo: () => boolean;
}

/** Build a FileEntry tree from a flat map of file paths */
export function buildFileTree(files: Record<string, string>): FileEntry[] {
  const root: FileEntry[] = [];
  const dirs = new Map<string, FileEntry>();

  const sortedPaths = Object.keys(files).sort();

  for (const filePath of sortedPaths) {
    const parts = filePath.split("/");
    let currentChildren = root;
    let currentPath = "";

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const isFile = i === parts.length - 1;

      if (isFile) {
        currentChildren.push({
          name: part,
          path: filePath,
          type: "file",
        });
      } else {
        let dir = dirs.get(currentPath);
        if (!dir) {
          dir = {
            name: part,
            path: currentPath,
            type: "directory",
            children: [],
          };
          dirs.set(currentPath, dir);
          currentChildren.push(dir);
        }
        currentChildren = dir.children!;
      }
    }
  }

  return root;
}

export const useEditorStore = create<EditorStore>((set, get) => ({
  openFiles: [],
  activeFilePath: null,
  generatedFiles: {},
  undoStack: [],
  redoStack: [],
  openFile: (path, content) =>
    set((state) => {
      const existing = state.openFiles.find((f) => f.path === path);
      if (existing) {
        // Update content if it changed (e.g., AI regenerated the file)
        const contentChanged = existing.content !== content;
        return {
          activeFilePath: path,
          openFiles: contentChanged
            ? state.openFiles.map((f) =>
                f.path === path ? { ...f, content, isDirty: false } : f
              )
            : state.openFiles,
        };
      }
      return {
        openFiles: [...state.openFiles, { path, content, isDirty: false }],
        activeFilePath: path,
      };
    }),
  closeFile: (path) =>
    set((state) => {
      const openFiles = state.openFiles.filter((f) => f.path !== path);
      const activeFilePath =
        state.activeFilePath === path
          ? openFiles[openFiles.length - 1]?.path ?? null
          : state.activeFilePath;
      return { openFiles, activeFilePath };
    }),
  setActiveFile: (path) => set({ activeFilePath: path }),
  updateFileContent: (path, content) =>
    set((state) => ({
      openFiles: state.openFiles.map((f) =>
        f.path === path ? { ...f, content, isDirty: true } : f
      ),
      generatedFiles: {
        ...state.generatedFiles,
        [path]: content,
      },
    })),
  markFileSaved: (path) =>
    set((state) => ({
      openFiles: state.openFiles.map((f) =>
        f.path === path ? { ...f, isDirty: false } : f
      ),
    })),
  addGeneratedFile: (path, content) =>
    set((state) => ({
      generatedFiles: { ...state.generatedFiles, [path]: content },
    })),
  addGeneratedFiles: (files) =>
    set((state) => ({
      generatedFiles: { ...state.generatedFiles, ...files },
    })),
  clearGeneratedFiles: () => set({ generatedFiles: {}, openFiles: [], activeFilePath: null, undoStack: [], redoStack: [] }),
  pushUndoSnapshot: () =>
    set((state) => ({
      undoStack: [...state.undoStack.slice(-(MAX_UNDO_HISTORY - 1)), { ...state.generatedFiles }],
      redoStack: [],
    })),
  undo: () => {
    const state = get();
    if (state.undoStack.length === 0) return;
    const prev = state.undoStack[state.undoStack.length - 1];
    set({
      undoStack: state.undoStack.slice(0, -1),
      redoStack: [...state.redoStack, { ...state.generatedFiles }],
      generatedFiles: prev,
    });
  },
  redo: () => {
    const state = get();
    if (state.redoStack.length === 0) return;
    const next = state.redoStack[state.redoStack.length - 1];
    set({
      redoStack: state.redoStack.slice(0, -1),
      undoStack: [...state.undoStack, { ...state.generatedFiles }],
      generatedFiles: next,
    });
  },
  canUndo: () => get().undoStack.length > 0,
  canRedo: () => get().redoStack.length > 0,
}));
